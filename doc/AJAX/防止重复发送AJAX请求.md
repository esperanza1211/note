#   防止重复发送AJAX请求

1.  独占型提交

只允许同时存在一次提交，并且直到本次提交完成才能进行下一次提交。

```
module.submit = function() {
  if (this.promise_.state() === 'pending') {
    return
  }
  return this.promise_ = $.post('/api/save')
}
```

2.  贪婪型提交

无限制的提交，但是以最后一次操作为准；亦即需要尽快给出最后一次操作的反馈，而前面的操作结果并不重要。

```
module.submit = function() {
  if (this.promise_.state() === 'pending') {
    this.promise_.abort()
  }
  // todo
}
```

比如某些应用的条目中，有一些进行类似「喜欢」或「不喜欢」操作的二态按钮。如果按下后不立即给出反馈，用户的目光焦点就可能在那个按钮上停顿许久；如果按下时即时切换按钮的状态，再在程序上用 abort 来实现积极的提交，这样既能提高用户体验，还能降低服务器压力，皆大欢喜。

3.  节制型提交

无论提交如何频繁，任意两次有效提交的间隔时间必定会大于或等于某一时间间隔；即以一定频率提交。

```
module.submit = throttle(150, function() {
  // todo
})
```

如果客户发送每隔100毫秒发送过来10次请求，此模块将只接收其中6个（每个在时间线上距离为150毫秒）进行处理。

这也是解决查询冲突的一种可选手段，比如以知乎草稿举例，仔细观察可以发现：

编辑器的 blur 事件会立即触发保存；

保存按钮的 click 事件也会立即触发保存；

但是存在一种情况会使这两个事件在数毫秒内连续发生——当焦点在编辑器内部，并且直接去点击保存按钮——这时用 throttle 来处理是可行的。

另外还有一些事件处理会很频繁地使用 throttle，如： resize、scroll、mousemove。

4.  懒惰型提交

任意两次提交的间隔时间，必须大于一个指定时间，才会促成有效提交；即不给休息不干活。

```
module.submit = debounce(150, function() {
  // todo
})
```

还是以知乎草稿举例，当在编辑器内按下 ctrl + s 时，可以手动保存草稿；如果你连按，程序会表示不理解为什么你要连按，只有等你放弃连按，它才会继续。

----

方式 3 和 方式 4 有时更加通用，比如这些情况：

*   游戏中你捡到一把威力强大的高速武器，为了防止你的子弹在屏幕上打成一条直线，可以 throttle 来控制频率；

*   在弹幕型游戏里，为了防止你把射击键夹住来进行无脑游戏，可以用 debounce 来控制频率；

*   在编译任务里，守护进程监视了某一文件夹里所有的文件（如任一文件的改变都可以触发重新编译，一次执行就需要2秒），但某种操作能够瞬间造成大量文件改变（如 git checkout），这时一个简单的 debounce 可以使编译任务只执行一次。

而方式 3 甚至可以和方式 2 组合使用，比如自动完成组件（Google 首页的搜索就是）：

*   当用户快速输入文本时（特别是打字能手），可以 throttle  keypress 事件处理函数，以指定时间间隔来提取文本域的值，然后立即进行新的查询；

*   当新的查询需要发送，但上一个查询还没返回结果时，可以 abort 未完成的查询，并立即发送新查询；


-----

如果是post请求，点一次和点两次是有区别的，比如点“回复评论”，点两次就相当于回复了两个内容一样的评论，所以一定要在UI上限制用户。

最简单的方法是点击后按钮置为disable状态，同时显示waiting动画，收到响应后再恢复正常按钮。一定要设置合理的timeout，不然用户会等得很焦虑。

如果post请求成功了但是因为timeout用户又提交了一次，要防止重复提交就只能在服务器端处理。最简单的做法是客户端对同一个form提交时产生一个相同的nonce参数，服务器收到相同的nonce参数时，仅处理第一个请求，这样就保持了幂等性。

如果是get请求，虽然和post比要求没那么高，用户点两次相当于发送了两个请求，但是先发送的请求不一定先收到响应，所以处理收到的响应可以以服务器响应内容里的时间戳为准，时间戳比较旧的响应直接忽略。


