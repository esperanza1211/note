#   数据结构

*   typeof  查看数据类型

    number/string/boolean/function/undefined/object

*   标准：

    *   基本类型：number/string/boolean/undefined/(null)

    *   复合类型：object(非空对象)

##  数据类型转换

*   ##  强制类型转换

### parseInt()    解析成整型

从第０位开始，一位一位的查看是否是数字，如果到某一位不是数字，就把这位之前的数字提取出来，如果第０位不是数字，就返回NaN。

parseInt(a, 10) (要转换的内容，　进制)

```
parseInt(0xf, 10)   //15
parseInt(0xf, 16)   //21
//0x:代表16进制
```

### parseFloat()    解析成浮点型(小数)

解析规则和parseInt一样，不一样的是，可以多解析一个小数点。

### Number()    转换成数值

数据类型 | 值 | 返回值
--- | --- | ---
String |  | 在进行数字转换时，完整的把要转换的内容看一遍，必须完全符合数字的规范才去进行转换，否则返回NaN
Boolean | true | 1
 | false | 0
null |  | 0
undefined |  | NaN
Function |  | NaN
数组 | 空数组 | 0
 | 当数组只有一位时，就去转换这一位数组 | 这一位是数字，或者字符串，或者undefined，就会进行转换，否则NaN。[undefined]=>0
 | 数组多位时 | NaN

### String()    转换成字符串

两侧加引号

toString()

### Boolean()   转换成布尔值

返回值 | 输入的内容
--- | ---
true | 非0的数字，非空字符串，函数，非空对象，数组(包括非空数组)
false | 0，NaN，空字符串，undefined，空对象/null

**空对象不能进行属性操作**

**空对象不等于空数组**

*   ##  隐式类型转换

### 运算符

*   算数运算符

    +, -, *, /, %, ++, --

*   赋值运算符

    =, +=, -=, *=, /=, %=

*   关系运算符(比较后都会返回布尔值)

    <, >, <=, >=, ==, !=, ===, !==

*   逻辑运算符

    &&, ||, !

    *   三目运算符

    判断条件?成立的返回值:不成立的返回值

++:

i++：先赋值，后计算

++i：先计算，后赋值

+,+=:

1.  碰到字符串就执行字符串拼接
2.  如果可以转换成数字，就进行数字相加
3.  如果不能把左右两边都转成数字，就执行字符串相加

-, *, /, %, ++, --:

会把左右两侧都转成数字，进行运算，不能转成数字就返回NaN

==, !=:

会进行类型转换

===, !==:

类型不一样,直接返回false

### ==和===的区别

==:

*   如果两个值具有相同的类型，那么就检测它们的等同性。如果这两个值完全相同，它们就相等，否则不相等

*   如果两个值的类型不同，它们仍然可能相等。用下面的规则和类型转换来检测它们的等同性。

    *   如果一个值是null，另一个值是undefined，它们相等
    *   果一个值是数字，另一个值是字符串，把字符串转换成数字，再用转换后的值进行比较
    *   如果一个值为true，将它转化为1，再进行比较。如果一个值为false，将它转化为0，再进行比较
    *   如果一个值是对象，另一个值是数字或字符串，将对象转换成原始类型的值，再比较
    *   其他的数值组合是不相等的

===:

*   如果两个值的类型不同，它们就不相同
*   如果两个值是数字，而且值相同，那么除非其中一个或两个都是NaN（这种情况它们不是等同的），否则它们是等同的。
*   如果两个值都是字符串，而且在串中同一位置上的字符完全相同，那么它们就完全等同。如果字符串的长度或内容不同，它们就不是等同的
*   如果两个值都是布尔值true，或者两个值都是布尔值false，那么它们等同
*   如果两个值引用的是同一个对象、数组或函数，那么它们完全等同。如果它们引用的是不同的对象，它们就不完全等同，即使这两个对象具有完全相同的属性，或两个数组具有完全相同的元素
*   如果两个值都是null或都是undefined，它们完全相同


### NaN:(not a number)

不是一个数字

typeof:number

**注意：NaN不等于任何数字，并且不等于它自己**

isNaN()     

检测一个数据转换成数字之后，是否是NaN，是 返回true，否则返回false

### 用逻辑运算简化判断

```
if( a != b ){
     fn();
} else {
     fn2();
};
function(){
     alert("条件成立");
};
function2(){
     alert("条件不成立");
};
```
简化后：
```
a!=b&&fn();
     //(当第一个条件成立时，才会去执行第二个条件)当左侧成立时就会只执行右侧代码，否则直接返回false
a!=b||fn2();
     //当第一个条件成立时，返回true，语句结束，条件不成立就会去执行右侧
function(){
     alert("条件成立");
};
function2(){
     alert("条件不成立");
};
```
